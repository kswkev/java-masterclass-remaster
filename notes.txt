SECTION 3: FIRST STEPS

21. Defining the Main Method (Project HelloWorld)

The Main method is the entry point for java applications
Main method is defined using public static void main(String[] args)
Intellij has a shortcut for this "psvm"
Text can be output using System.out.println("blah")
Intellij has a shortcut for this "sout"

23. Variables (MyFirstNumber)

24. Starting out with Expressions (MyExtraNumbers)

25. Primitive Types (ByteShortIntLong)

primitive types int (for holding numbers)
defined
	int <variableName> = <number>;

int holds between -2,147,483,648 and 2,147,483,647 values up to 2^31, it's 32 bit but one bit is used for -/+
moving outside it's range will cause the value to wrap around i.e. -2,147,483,648 - 1 = 2,147,483,647
ints can also be defined using underscores rather than commas i.e. 2_147_483_647

26. byte, short, long and width (ByteShortIntLong)

more primitives for holding numbers, byte, short and long

ranges are
byte: -128 - 127 (2^7)
short: -32,768 - 32,767 (2^15)
long: -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807 (2^63)

27. Casting in Java (CastingInJava)

by default numbers and calculations are assumed to be int, to store values as byte or short they need to be cast using:

byte <var> = (byte) <expression>;
short <var> = (short) <expression>

longs can be defined with L at the end of a literal number i.e. 200L

28. Primitive Type Challenge (PrimitiveTypeChallenge)

29. Float and double Primitive Types (FloatAndDouble)

primitive types float and double used for storing decimals
defined
	float <variableName> = <decimal>;
	double <variableName> = <decimal>;

ranges are
float: 1.4e-45 - 3.4028235e38
double: 4.9e-324 - 1.7976931348623157e308

decimals are assumed to be double and need to be cast as float either by using (float) or by added f after a literal
doubles can be cast using a d i.e 200d

30. Floating Point Precision and a Challenge (PoundsToKilogramsChallange)

31. The char and boolean Primitive Data Types (CharAndBoolean)

Primitive type char is used to store a single unicode character
defined
	char <var> = '<character>'; or char <var> = '\u<unicode value>';

unicode values can be found https://unicode-table.com/en/

primitive type boolean holds either true or false
defined
	boolean <var> = true/false;

32. Primitive Types Recap and the String Data Type (Strings)

The class String can be used to hold text
defined
	String <var> = "<some text>";

Strings can also hold unicode characters i.e. mystring = "\u00A9 2019"
Strings can be concatinated using + i.e. myNewString = myOldString + " some new text";
Strings are immutable i.e. when strings are overwritten the old value is discarded and a new one created
Concatinating numbers with string will automatically turn the numbers to strings

33. Operators, Operands and Expressions (Operators)

Operators
Special symbols that perform specific operations on one, two or three operands and return a result. e.g. 10 + 20, + is the operator

Operands
Any object that is manipulated by an operator e.g. int myVar = 15 + 12, 15 & 12 are the operands

Expression
A combination of variables, literals, method returns and operators e.g. int myVar = 15 + 12, 15 + 12 is the expression

example operators:
+ addition
- subtraction
* multiplication
/ division
% mod (the remainder of a division, 4 % 11 = 3)

34. Abbreviating Operators (Operators)

There are shorthands of applying operators to the same var:

<var>++ or <var>-- will increment or decrement the variable by 1

<var> += <value> adds value to var
<var> -= <value> subtracts value from var
<var> *= <value> multiplies var by value
<var> /= <value> divides var by value

35. if-then Statement (IfThen)

If then statements are conditional logic that allows preceeding lines of code to be ran or not depending on the evanuation of the condition, syntax is:

if (<condition>) then
	code to run if <condition> is true

the above is valid but this is clearer

if (<condition>) then {
	code to run if <condition> is true
	}

any code between the {} will be ran where as the first example will only run the next line

36. Logical AND Operator (LogicalAndOperator)

There are a number of different coditional operators that can be used in an if statement:

a == b, a equal to b
a != b, a not equal to b
a > b, a greater than b
a >= b, a greater than or equal to b
a < b, a less than b
a <= b, a less than or equal to b

The and operator "&&" can be used to combine multiple conditions into one, it will evaluate to true if all conditions are true

e.g.

if (a == b && a > 100) {
	do something
}

37. Logical OR Operator (LogicalOrOperator)

Like the and operator, the or operator "||" is used to combine multiple conditions, it will evaluate to true if any conditions are true

e.g.

if (a == b || a > 100) {
	do something
}

39. Ternary Operator (TernaryOperator)

The ternary operator is used to set a value based on a condition, it's usually a shortcut to if else. The syntax is:
<var> = <condition> ? <true value> : <false value>

e.g.
boolean isCanDrink  = (age >= 18) ? true : false;

parentheses is just to make things more readable and isn't required

40. Operator Precedence and Operator Challenge (OperatorChallenge)

Useful links:
list of operators: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html
operator precedence table: http://www.cs.bilkent.edu.tr/~guvenir/courses/CS101/op_precedence.html


SECTION 4: JAVA TUTORIAL: EXPRESSIONS, STATEMENTS, CODE BLOCKS, METHODS AND MORE

44. Keywords And Expressions

list of reserved keywords: https://en.wikipedia.org/wiki/List_of_Java_keywords

expressions are a combination of variables. values and operators, e.g

in
double kilometers = (100 * 1.609344);
int highScore = 50;
if (highScore == 50) {
	System.out.println("This is an expression");
}

the expressions are:
kilometers = (100 * 1.609344)
highScore = 50
highScore == 50
"This is an expression"

45. Statements, whitespace and indentation

a statement is a complete line of java (or multiple lines) ending in a ;

java doesn't care about whitespace or indentation, you can add them as you please

46. Code block and the If Then Else Control Statements (IfThenElse)

code blocks are defined using {}, anything between the brackets is a code block

if statements can have a number of else's attached to them that are executed if the if condition is false

e.g.

if (<condition>) {
	do something if true
} else {
	do something else if false
}

else can also be combined with if to check a second condition, this can also have an else

e.g.

if (<condition 1>) {
	do something if condition 1 true
} else if (<condition 2>) {
	do something if condition 1 false but condition 2 is true
} else {
	do something if neither are true
}

48. Methods in Java (MethodsInJava)

A method is a reusuable code block and defined as:

<access type> <return type> <name>(<parameters>)

e.g. public int countMoney(int money1, int money2)

Methods are called using their name and providing arguments for any parameters

e.g. countMoney(100, 500);

If a return type is specificed (void can be used if nothing is returned), a value of that type must be returned at the completion of any logical code block in the method. Missing this will cause an error.

e.g.

public int findLarger(int money1, int money2) {

	if (money1 > money2) {
		return money2;
	} else {
		return money1;
	}
}

49. More On Methods And A Challenge (DisplayHighScorePositionChallange)

58. Method Overloading (MethodOverloading)

Method signatures are made up of the method name and types of arguments. Method signatures must be unqiue within a class but this allows
for the same method name to be used as long as the number or types of arguments are different.

e.g.

public static int doCalc(int value)
public static int doCalc(long value)
public static int doCalc(int value1, int value2)

can all exist in the same class

SECTION 5: CONTROL FLOW STATEMENTS

63. The switch statement (TheSwitchStatement)

The switch statement can be used to decide which code to run based on the value of a control variable, it's sytax is:

switch (<control var>) {
	case <condition value>:
		code to run
		break;
	repeat for each condition

	default:
		code to run
		break;
}

default like an else in at if statement catches anything that doesn't meet other conditions e.g.

	int switchValue = 1;

        switch (switchValue) {
            case 1:
                System.out.println("Value was 1");
                break;

            case 2:
                System.out.println("Value was 2");
                break;

            case 3: case 4:case 5:
                System.out.println("Value was either 3, 4, or 5");
                break;

            default:
                System.out.println("Was not 1-5");
                break;
        }

switch will work with only certain types, the primatives byte, short, char and int + String for java 7 and above.
All blocks of code must include a break as the last command otherwise the next code block will also execute.

65. The for Statement (TheForStatement)

The for statment (or for loop) can be used to repatidly execute a code block until a given condition is no longer met, the syntax is:

for (<control initialisation>; <termination condition>; <step>) {
	<code to repeat>
}

e.g.

for (int i=0; i <10; i++) {
	System.out.println(i);
}

the above will output 0-9, i starts out at 0 and increase by 1 each time the loop completes. Once i reaches 10, the control condition is
no longer true and the loop ends.

68. The while and do while statements (WhileAndDoWhileStatements)

The while statement (or loop) is another loop that will execute a block of code repatidly until a given condition is no longer met, unlike
the for loop while does not have a controlling variable. It's syntax is:

while (<control condition>) {
	<code to repeat>
}

e.g.

while (count < 10) {
	count++;
}

There is also a do while form of this loop, that will always execute the code block at least once.

do {
	<code to repeat>
} while (<control condition>);

There are 2 other statements that can be used with loops, break and continue. Break will compleatly terminate the loop regardless of the control condtion. Continue will stop execution of the code block and move to the next iteration of the loop.

71. Parsing Values from a String (ParsingValuesFromString)

Strings can be converted into primative numbers int, long, double etc, using parse methods build into the Integer, Long, Double etc classes, e.g.

String numberAsString = "2018";
int number = Integer.parseInt(numberAsString);

Trying to pass anything other than a numerical value into these methods will throw a NumberFormatException.

72. Reading User Input

The Scanner class (java.util.Scanner) and it's methods can be used to read input from various sources, including the command line. A new instance can be created to read from the command line using:

Scanner scanner = new Scanner(System.in);

and should be closed after all operations are completed using:

scanner.close();

The scanner can read a line of text into a String variable using the nextLine() method:

String name = scanner.nextLine();

The scanner can also return numbers using certain methods that are automatically parsed:

int yearOfBirth = scanner.nextInt();

note: you may have to call nextLine right after this if requesting multiple values from the user.

SECTION 6 OOP Part 1 - Classes, Constructors and Inheritance

77. Classes (Classes)

A class is an object that contains properties and behavious (or fields and methods). The syntax for a class is:

<access type> class <name> {

}

e.g.

public class Car {

}

Class names should always start with an uppercase letter.

A new instance of a class can be created using the new keyword e.g. Car myCar = new Car();

Under OOP principes all fields in a class should be private and accessed using methods, e.g.

public class Car {

    private String model;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

}

note: IntelliJ's can create getters and setters for you, Code menu > generate > getters and setters. 

79. Constructors (BankingChallenge)

A constructor is a special type of method that is called to create a object when the new keyword is used. There is a default constructor inherated can has no arguments, a zero argument constructor. This can be overwritten thou.

Other constructors can be created using overloading. The this keyword can be used to call other constructors.

e.g.

public class Car {

	private String model;

	public Car() {
		this("default");
	}

	public Car(String model) {
		this.model = model;
	}
}

note: IntelliJ's can create constructors for you using the Code menu > generate.

81. Inheritance (Inheritance)

Classes can build upon other classes using inheritance. This allows a class the abililty to access fields and methods of any class it inheritants from (in java this is done throught the extends keyword).

e.g.

public class Dog extends Animal {

}

This gives Dog access to the fields and methods of Animal.

Classes can override the functionality of it's parents methods by creating it's own version, using the @Override annotation makes it clear that's what happening.

e.g.

public class Animal {

	public void eat() {

	}
}

public class Dog extends Animal {

	@Override
	public void eat() {

	}
} 

Note: IntelliJ provides overridding options in the Code menu > generate.

Classes can access the methods or fields of the parent using the super keyword. If Dog want to access the Animal version of eat it could call it using super.eat().

83. Reference vs Object vs Instance vs Class (ReferenceVsOjectVsInstanceVsClass)

Class: the blueprint used to create an instance or object
Object / instance: created using the new keyword
Reference: a pointer to an object in memory

84. This vs super (ThisVsSuper)

this: refers to the current object, usually used in setter methods
super: refers to the parent object, usually used when overriding methods to access the parent method
this(): the constructor used within the same class
super(): the parent version of the constructor

85. Method Overloading vs Overriding (MethodOverloadingVsOverriding)

overloading: multiple methods with the same name but different parameters
overriding: a subclass defining a method with the same name and parameters as the parent class

86. Static vs Instance methods (StaticVsInstanceMethods)

When a method doesn't require the use of any instance fields or instance methods, it should be static.
Instance methods require the use of fields or instance methods

87. Static vs Instance variables (StaticVsInstanceVariables)

There are a set of instance variables for each instance of that class, whereas static variables are shared between all instances

SECTION 7: OOP Part 2 - Composition, Encapsulation, and Polymorphism

91. Composition (CompositionChallenge)

Composition is the term in OOP whereby a class contains other classes as fields and interaction with those fields is done via the containing class